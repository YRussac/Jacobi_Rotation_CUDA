#include "JacobiData.cu"#include "random"#include "iostream"void testCUDA(cudaError_t error, const char *file, int line){    if (error != cudaSuccess){        printf("Error in file %s at line %d \n", file , line);        exit(EXIT_FAILURE);    }}#define testCUDA(error) (testCUDA(error, __FILE__,__LINE__))__global__ void compute(JacobiData *jacobi_array, int optimisation) {    int block_size = blockDim.x;    switch (optimisation){        case 1 : jacobi_array[blockIdx.x].jacobi_product();        case 2 : jacobi_array[blockIdx.x].jacobi_product_parallel_cols(block_size);        case 3 : jacobi_array[blockIdx.x].jacobi_product_parallel(block_size);    }    }void cpu_run() {    std::clock_t start;    double duration;    start = std::clock();    JacobiData jacobi;//    jacobi.debug_fill();    jacobi.jacobi_product();    jacobi.free_memory();    duration = ( std::clock() - start ) / (double) CLOCKS_PER_SEC;    std::cout<<"printf: "<< duration <<'\n';}void gpu_run(int optimisation) {    const int n_problems = 1;    const int n_blocks = n_problems;    int count;    cudaDeviceProp prop;    testCUDA(cudaGetDeviceCount(&count));    testCUDA(cudaGetDeviceProperties(&prop, count-1));    float TimerV;    cudaEvent_t start, stop;    testCUDA(cudaEventCreate(&start));    testCUDA(cudaEventCreate(&stop));    testCUDA(cudaEventRecord(start,0));//  Define the array of problems    JacobiData *jacobi_array;    cudaMallocManaged(&jacobi_array, n_problems * sizeof(JacobiData));    for (int j = 0; j < n_problems; ++j) {        jacobi_array[j] = JacobiData();//        jacobi_array[j].debug_fill();    }    print_matrix(jacobi_array[0].A, jacobi_array[0].d, "Initial matrix A number 0");//    On GPU    compute << < n_blocks, N_THREADS >> > (jacobi_array, optimisation);    // Wait for GPU to finish before accessing on host    cudaDeviceSynchronize();    print_matrix(jacobi_array[0].A, jacobi_array[0].d, "Output matrix A number 0");    for (int i = 0; i < n_problems; ++i) {        jacobi_array[i].free_memory();    }    testCUDA(cudaEventRecord(stop,0));    testCUDA(cudaEventSynchronize(stop));    testCUDA(cudaEventElapsedTime(&TimerV,start,stop));    printf("Execution time: %f ms\n", TimerV);}int main() {    int optimisation = 0;    switch(optimisation) {            case 0 : cpu_run();            case 1 : gpu_run(1);            case 2 : gpu_run(2);            case 3 : gpu_run(3);        }    return 0;}