#include "JacobiData.cu"#include "random"#include "iostream"__global__ void compute(JacobiData *jacobi_array) {    int block_size = blockDim.x;//    jacobi_array[blockIdx.x].jacobi_product_parallel_cols(block_size);    jacobi_array[blockIdx.x].jacobi_product_parallel(block_size);}void cpu_run() {    JacobiData jacobi;    jacobi.debug_fill();    jacobi.jacobi_product();    jacobi.free_memory();}void gpu_run() {    const int n_problems = 1;    const int n_blocks = n_problems;//  Define the array of problems    JacobiData *jacobi_array;    cudaMallocManaged(&jacobi_array, n_problems * sizeof(JacobiData));    for (int j = 0; j < n_problems; ++j) {        jacobi_array[j] = JacobiData();        jacobi_array[j].debug_fill();    }    print_matrix(jacobi_array[0].A, jacobi_array[0].d, "Initial matrix A number 0");//    On GPU    compute << < n_blocks, N_THREADS >> > (jacobi_array);    // Wait for GPU to finish before accessing on host    cudaDeviceSynchronize();    print_matrix(jacobi_array[0].A, jacobi_array[0].d, "Output matrix A number 0");    for (int i = 0; i < n_problems; ++i) {        jacobi_array[i].free_memory();    }}int main() {    gpu_run();    return 0;}